// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// User model
model User {
  id                  String        @id @default(cuid())
  name                String?
  email               String?       @unique
  emailVerified       DateTime?
  image               String?
  plexUserId          String?       @unique
  isAdmin             Boolean       @default(false)
  onboardingCompleted Boolean       @default(false)
  plexWrapped         PlexWrapped[]
  llmUsage            LLMUsage[]
  chatConversations   ChatConversation[]
  inviteUsages        InviteUsage[]
  discordConnection   DiscordConnection?
  discordOAuthStates  DiscordOAuthState[]
  userMediaMarks      UserMediaMark[]
  userWatchIntents    UserWatchIntent[]
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  @@index([plexUserId])
  @@index([isAdmin])
  @@index([onboardingCompleted])
}

// Setup and Configuration models
model Setup {
  id          String    @id @default(cuid())
  isComplete  Boolean   @default(false)
  currentStep Int       @default(1)
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model PlexServer {
  id              String   @id @default(cuid())
  name            String
  url             String   // Full URL including protocol, hostname, and port (e.g. https://plex.example.com:32400)
  publicUrl       String?  // Public facing URL (e.g. https://plex.example.com)
  token           String
  adminPlexUserId String? // Plex user ID of the admin (user who configured this server)
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([isActive])
  @@index([adminPlexUserId])
}

model Tautulli {
  id        String   @id @default(cuid())
  name      String
  url       String   // Full URL including protocol, hostname, and port (e.g. http://tautulli.example.com:8181)
  publicUrl String?  // Public facing URL (e.g. https://tautulli.example.com)
  apiKey    String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
}

model Overseerr {
  id        String   @id @default(cuid())
  name      String
  url       String   // Full URL including protocol, hostname, and port (e.g. http://overseerr.example.com:5055)
  publicUrl String?  // Public facing URL (e.g. https://requests.example.com)
  apiKey    String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
}

model Sonarr {
  id        String   @id @default(cuid())
  name      String
  url       String   // Full URL including protocol, hostname, and port (e.g. http://sonarr.example.com:8989)
  publicUrl String?  // Public facing URL (e.g. https://sonarr.example.com)
  apiKey    String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  maintenanceRules MaintenanceRule[]

  @@index([isActive])
}

model Radarr {
  id        String   @id @default(cuid())
  name      String
  url       String   // Full URL including protocol, hostname, and port (e.g. http://radarr.example.com:7878)
  publicUrl String?  // Public facing URL (e.g. https://radarr.example.com)
  apiKey    String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  maintenanceRules MaintenanceRule[]

  @@index([isActive])
}

model LLMProvider {
  id          String   @id @default(cuid())
  provider    String // Currently "openai", but extensible for other providers
  purpose     String // "chat" or "wrapped" - distinguishes between chat assistant and wrapped generation configs
  apiKey      String
  model       String // Required - no default model allowed
  temperature Float? // Temperature setting (0.0-2.0), null uses model default
  maxTokens   Int? // Max tokens for completion, null uses default (6000)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive])
  @@index([provider])
  @@index([purpose])
}

// Plex Wrapped models
model PlexWrapped {
  id          String              @id @default(cuid())
  userId      String
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  data        String // JSON string containing wrapped data
  year        Int // Year this wrapped is for
  status      String              @default("pending") // "pending", "generating", "completed", "failed"
  error       String? // Error message if status is "failed"
  shareToken  String?             @unique // Random token for sharing (URL-safe, unguessable)
  summary     String? // Shareable summary text for social sharing
  generatedAt DateTime?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  llmUsage    LLMUsage[] // Multiple LLM usage records can be associated with a wrapped (for regenerations)
  shareVisits WrappedShareVisit[] // Track visits to shared wraps

  @@unique([userId, year])
  @@index([userId])
  @@index([year])
  @@index([status])
  @@index([shareToken])
}

// Track visits to shared wraps
model WrappedShareVisit {
  id        String      @id @default(cuid())
  wrappedId String
  wrapped   PlexWrapped @relation(fields: [wrappedId], references: [id], onDelete: Cascade)
  ipAddress String? // IP address of the visitor (for analytics)
  userAgent String? // User agent string (for analytics)
  referer   String? // Referer URL if available
  createdAt DateTime    @default(now())

  @@index([wrappedId])
  @@index([createdAt])
}

model ChatConversation {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  endedAt   DateTime?
  usage     LLMUsage[]
  discordSessions DiscordChatSession[]

  @@index([userId])
  @@index([createdAt])
}

// LLM Usage tracking for cost analysis
// This model stores ALL LLM usage, including regenerations of wrapped content
// wrappedId is optional to allow tracking LLM usage even without a wrapped
model LLMUsage {
  id               String       @id @default(cuid())
  wrappedId        String? // Optional - allows tracking usage without a wrapped
  wrapped          PlexWrapped? @relation(fields: [wrappedId], references: [id], onDelete: SetNull)
  chatConversationId String?
  chatConversation   ChatConversation? @relation(fields: [chatConversationId], references: [id], onDelete: SetNull)
  userId           String
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider         String // Currently "openai", but extensible for other providers
  model            String? // Model used (e.g., "gpt-4", "openai/gpt-4")
  prompt           String // The prompt sent to the LLM
  response         String // The full response from the LLM
  promptTokens     Int // Number of tokens in the prompt
  completionTokens Int // Number of tokens in the completion
  totalTokens      Int // Total tokens used
  cost             Float // Estimated cost in USD
  createdAt        DateTime     @default(now())

  @@index([userId])
  @@index([wrappedId])
  @@index([chatConversationId])
  @@index([provider])
  @@index([createdAt])
}

// Application Configuration (singleton pattern)
model Config {
  id                        String    @id @default("config")
  llmDisabled               Boolean   @default(false) // When true, LLM calls are disabled and mock data is returned
  wrappedEnabled            Boolean   @default(true) // When false, wrapped generation is disabled
  wrappedGenerationStartDate DateTime? // Optional start date for when generation is allowed (e.g., Nov 20). Year is auto-determined from this date.
  wrappedGenerationEndDate   DateTime? // Optional end date for when generation is allowed (e.g., Jan 31)
  updatedAt                DateTime  @updatedAt
  updatedBy                 String?   // User ID who last updated this config
}

model DiscordIntegration {
  id               String   @id @default("discord")
  isEnabled        Boolean  @default(false)
  botEnabled       Boolean  @default(false)
  clientId         String?
  clientSecret     String?
  guildId          String?
  serverInviteCode String?
  platformName     String   @default("Plex Wrapped")
  instructions     String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  updatedBy        String?
}

// Distributed lock for Discord bot (ensures only one pod runs the bot)
model DiscordBotLock {
  id           String   @id @default("discord-bot")
  instanceId   String   // Unique identifier for this pod/instance
  acquiredAt   DateTime @default(now())
  expiresAt    DateTime // Lock expires if not renewed (handles crashed pods)
  lastRenewedAt DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([expiresAt])
}

model DiscordConnection {
  id               String   @id @default(cuid())
  userId           String   @unique
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  discordUserId    String   @unique
  username         String
  discriminator    String?
  globalName       String?
  avatar           String?
  accessToken      String
  refreshToken     String?
  scope            String?
  expiresAt        DateTime?
  metadataSyncedAt DateTime?
  linkedAt         DateTime @default(now())
  revokedAt        DateTime?
  lastError        String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([discordUserId])
  @@index([linkedAt])
}

model DiscordChatSession {
  id                 String            @id @default(cuid())
  discordUserId      String
  discordChannelId   String
  chatConversationId String
  chatConversation   ChatConversation  @relation(fields: [chatConversationId], references: [id], onDelete: Cascade)
  messages           Json
  lastMessageAt      DateTime          @default(now())
  isActive           Boolean           @default(true)
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt

  @@unique([discordUserId, discordChannelId])
  @@index([discordUserId])
  @@index([chatConversationId])
}

model DiscordOAuthState {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  state        String   @unique
  codeVerifier String
  redirectTo   String?
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  consumedAt   DateTime?

  @@index([state])
  @@index([userId])
  @@index([expiresAt])
}

// Prompt Template for LLM generation
model PromptTemplate {
  id          String   @id @default(cuid())
  name        String // Human-readable name for the template
  description String? // Optional description
  template    String // The prompt template with placeholders like {{userName}}, {{year}}, etc.
  isActive    Boolean  @default(false) // Only one active template at a time
  version     Int      @default(1) // Version number for tracking changes
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedBy   String? // User ID who last updated this template

  @@index([isActive])
  @@index([name])
}

// Server Statistics are now calculated on the fly - no database caching needed

model Invite {
  id        String    @id @default(cuid())
  code      String    @unique
  maxUses   Int       @default(1)
  useCount  Int       @default(0)
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  createdBy String? // Admin User ID who created the invite

  // Library access settings
  librarySectionIds String? // JSON array of library section IDs to share (null = all libraries)
  allowDownloads    Boolean @default(false) // Allow downloads (allowSync)

  usages InviteUsage[]

  @@index([code])
}

model InviteUsage {
  id       String   @id @default(cuid())
  inviteId String
  invite   Invite   @relation(fields: [inviteId], references: [id], onDelete: Cascade)
  userId   String
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  usedAt   DateTime @default(now())

  @@index([inviteId])
  @@index([userId])
}

// Library Maintenance Models
model MaintenanceRule {
  id          String   @id @default(cuid())
  name        String
  description String?
  enabled     Boolean  @default(true)
  mediaType   MediaType

  // Rule criteria stored as JSON
  criteria    Json

  // Actions
  actionType  ActionType
  actionDelayDays Int? // Optional delay before executing action (in days)

  // Target server instances (optional - defaults to active server if not specified)
  radarrId    String?
  radarr      Radarr?  @relation(fields: [radarrId], references: [id], onDelete: SetNull)
  sonarrId    String?
  sonarr      Sonarr?  @relation(fields: [sonarrId], references: [id], onDelete: SetNull)

  // Schedule (cron expression)
  schedule    String?

  // Statistics
  lastRunAt   DateTime?
  nextRunAt   DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  scans       MaintenanceScan[]

  @@index([enabled])
  @@index([nextRunAt])
  @@index([mediaType])
}

model MaintenanceScan {
  id              String   @id @default(cuid())
  ruleId          String
  rule            MaintenanceRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  status          ScanStatus
  startedAt       DateTime?
  completedAt     DateTime?
  error           String?

  // Statistics
  itemsScanned    Int      @default(0)
  itemsFlagged    Int      @default(0)

  createdAt       DateTime @default(now())

  // Relations
  candidates      MaintenanceCandidate[]

  @@index([ruleId, createdAt])
  @@index([status])
}

model MaintenanceCandidate {
  id              String   @id @default(cuid())
  scanId          String
  scan            MaintenanceScan @relation(fields: [scanId], references: [id], onDelete: Cascade)

  // Media identification
  mediaType       MediaType
  plexRatingKey   String
  radarrId        Int?
  sonarrId        Int?
  tmdbId          Int?
  tvdbId          Int?

  // Media details (cached for display)
  title           String
  year            Int?
  poster          String?
  filePath        String?
  fileSize        BigInt?

  // Watch statistics
  playCount       Int      @default(0)
  lastWatchedAt   DateTime?
  addedAt         DateTime?

  // Rule evaluation
  matchedRules    Json
  flaggedAt       DateTime @default(now())

  // Review status
  reviewStatus    ReviewStatus
  reviewedAt      DateTime?
  reviewedBy      String?
  reviewNote      String?

  // Deletion tracking
  deletedAt       DateTime?
  deletionError   String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([scanId, reviewStatus])
  @@index([mediaType, reviewStatus])
  @@index([reviewStatus, flaggedAt])
  @@index([mediaType, plexRatingKey])
  @@unique([scanId, plexRatingKey])
}

model MaintenanceDeletionLog {
  id              String   @id @default(cuid())
  candidateId     String?

  mediaType       MediaType
  title           String
  year            Int?
  fileSize        BigInt?

  deletedBy       String
  deletedAt       DateTime @default(now())

  deletedFrom     String
  filesDeleted    Boolean

  ruleNames       Json

  @@index([deletedAt])
  @@index([deletedBy])
}

model UserMediaMark {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Media identification
  mediaType       MediaType
  plexRatingKey   String

  // Radarr/Sonarr IDs (if available)
  radarrId        Int?
  radarrTitleSlug String?
  sonarrId        Int?
  sonarrTitleSlug String?

  // Media metadata (cached for display)
  title           String
  year            Int?
  seasonNumber    Int?
  episodeNumber   Int?
  parentTitle     String?

  // Mark details
  markType        MarkType
  note            String?

  // Tracking
  markedAt        DateTime @default(now())
  markedVia       String
  discordChannelId String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId, mediaType])
  @@index([plexRatingKey])
  @@index([markType])
  @@index([markedAt])
  @@unique([userId, plexRatingKey, markType])
}

model UserWatchIntent {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  plexRatingKey   String
  mediaType       MediaType
  title           String

  // Intent tracking
  intentType      IntentType
  priority        Int        @default(0)

  // Progress (for TV series)
  currentSeason   Int?
  currentEpisode  Int?

  addedAt         DateTime @default(now())
  updatedAt       DateTime @updatedAt
  completedAt     DateTime?

  @@index([userId, intentType])
  @@index([plexRatingKey])
  @@unique([userId, plexRatingKey])
}

enum MediaType {
  MOVIE
  TV_SERIES
  EPISODE
}

enum ScanStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
  DELETED
}

enum ActionType {
  FLAG_FOR_REVIEW      // Flag media for manual review
  AUTO_DELETE          // Automatically delete from disk and remove from Radarr/Sonarr
  UNMONITOR_AND_DELETE // Unmonitor in Radarr/Sonarr and delete from disk
  UNMONITOR_AND_KEEP   // Unmonitor in Radarr/Sonarr but keep files
  DO_NOTHING           // Take no action (useful for reporting only)
}

enum MarkType {
  FINISHED_WATCHING
  NOT_INTERESTED
  KEEP_FOREVER
  REWATCH_CANDIDATE
  POOR_QUALITY
  WRONG_VERSION
}

enum IntentType {
  PLAN_TO_WATCH
  WATCHING
  COMPLETED
  DROPPED
  ON_HOLD
}

// Discord Command Audit Log - tracks all Discord bot interactions
model DiscordCommandLog {
  id              String   @id @default(cuid())

  // Discord user info
  discordUserId   String
  discordUsername String?

  // Linked Plex user (if available)
  userId          String?

  // Command details
  commandType     DiscordCommandType
  commandName     String              // e.g., "!finished", "!assistant", "!clear"
  commandArgs     String?             // Arguments passed to the command

  // Context
  channelId       String
  channelType     String              // "dm", "support-channel", "thread"
  guildId         String?

  // Execution details
  status          DiscordCommandStatus @default(PENDING)
  error           String?
  responseTimeMs  Int?                // Time to process the command

  // Timestamps
  startedAt       DateTime @default(now())
  completedAt     DateTime?

  createdAt       DateTime @default(now())

  @@index([discordUserId])
  @@index([userId])
  @@index([commandType])
  @@index([commandName])
  @@index([status])
  @@index([createdAt])
  @@index([channelId])
}

enum DiscordCommandType {
  CHAT          // Chatbot interactions (!assistant, !bot, !support, DMs, mentions)
  MEDIA_MARK    // Media marking commands (!finished, !not-interested, etc.)
  CLEAR_CONTEXT // Context clear commands (!clear, !reset)
  SELECTION     // Numeric selection responses (1-5)
  LINK_REQUEST  // User not linked, requested to link account
}

enum DiscordCommandStatus {
  PENDING
  SUCCESS
  FAILED
  TIMEOUT
}
